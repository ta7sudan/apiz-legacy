{"version":3,"file":"apiz.cjs.js","sources":["../src/core.ts","../src/querystring.ts","../src/index.ts"],"sourcesContent":["export type HTTPMethodUpperCase = 'GET' | 'POST' | 'HEAD' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS';\n\nexport type HTTPMethodLowerCase = 'get' | 'post' | 'head' | 'put' | 'patch' | 'delete' | 'options';\n\nexport type HTTPMethod = HTTPMethodUpperCase | HTTPMethodLowerCase;\n\ninterface APIInfoWithURL<ContentType, Meta> {\n\turl: string;\n\tmethod?: HTTPMethod;\n\ttype?: ContentType;\n\tmeta?: Meta;\n}\n\ninterface APIInfoWithPath<ContentType, Meta> {\n\tbaseURL?: string;\n\tpath: string;\n\tmethod?: HTTPMethod;\n\ttype?: ContentType;\n\tmeta?: Meta;\n}\n\nexport type APIInfo<ContentType = any, Meta = any> =\n\t| APIInfoWithURL<ContentType, Meta>\n\t| APIInfoWithPath<ContentType, Meta>;\n\nexport interface APIGroup<\n\tT extends Record<string, APIInfo<any, any>> = Record<string, APIInfo<any, any>>\n> {\n\tbaseURL?: string;\n\tapis: T;\n}\n\nexport interface ClientRequestOptions<RawRequestOptions, ContentType, Meta> {\n\turl: string;\n\tname: string;\n\tmeta?: Meta;\n\toptions?: RawRequestOptions;\n\tbody?: any;\n\tparams?: Record<string, string>;\n\tquery?: string | Record<string, any>;\n\theaders?: Record<string, any>;\n\ttype?: ContentType;\n\thandleError?: boolean;\n}\n\nexport type APIzClientRequest<RawRequestOptions, ContentType, Meta> = (\n\toptions: ClientRequestOptions<RawRequestOptions, ContentType, Meta>\n) => Promise<any>;\n\nexport type APIzClient<\nRawRequestOptions,\nContentType,\nMeta,\nMethod extends HTTPMethodLowerCase = HTTPMethodLowerCase\n> = {[k in Method]: APIzClientRequest<RawRequestOptions, ContentType, Meta>};\n\nexport type Serialize2QueryString = (obj: any) => string;\n\nexport interface APIzOptions<\n\tRawRequestOptions,\n\tContentType,\n\tMeta,\n\tMethod extends HTTPMethodLowerCase = HTTPMethodLowerCase\n> {\n\tbaseURL?: string;\n\tclient?: APIzClient<RawRequestOptions, ContentType, Meta, Method>;\n\tparamRegex?: RegExp;\n\tquerystring?: Serialize2QueryString;\n}\n\nexport interface GlobalAPIzOptions<\n\tRawRequestOptions,\n\tContentType,\n\tMeta,\n\tMethod extends HTTPMethodLowerCase = HTTPMethodLowerCase\n> {\n\tclient?: APIzClient<RawRequestOptions, ContentType, Meta, Method>;\n\tparamRegex?: RegExp;\n\tdefaultType?: ContentType;\n\treset?: boolean;\n\tquerystring?: (obj: any) => string;\n}\n\ntype Callable = (...args: Array<any>) => any;\n\ninterface ParsedAPIInfo<RawRequestOptions, ContentType, Meta, Method extends HTTPMethodLowerCase> {\n\turl: string;\n\tbaseURL: string;\n\tpath: string;\n\tname: string;\n\tmeta?: Meta;\n\tmethod: HTTPMethodUpperCase;\n\tmethodLowerCase: Method;\n\ttype?: ContentType;\n\tregex: RegExp;\n\tquerystring: Serialize2QueryString;\n\tinit: boolean;\n\tclient: APIzClient<RawRequestOptions, ContentType, Meta, Method>;\n}\n\ntype ContentTypeFrom<R> = R extends Record<string, APIInfo<infer C, infer M>>\n\t? C extends unknown\n\t\t? any\n\t\t: C\n\t: never;\n\ntype ProxyGroup<RawRequestOptions, T extends Record<string, APIInfo<any, any>>> = {\n\t[k in keyof T]: RequestWithoutThis<RawRequestOptions, ContentTypeFrom<T>>\n};\n\nexport type APIzInstance<\nRawRequestOptions = any,\nT extends Record<string, APIInfo<any, any>> = Record<string, APIInfo<any, any>>,\nMethod extends HTTPMethodLowerCase = HTTPMethodLowerCase\n> = Omit<ProxyGroup<RawRequestOptions, T>, 'add'> & {\n\tadd: (\n\t\tname: string,\n\t\tapiInfo: T extends Record<string, infer I>\n\t\t? I extends APIInfo<infer C, infer M>\n\t\t? APIInfo<C extends unknown ? any : C, M extends unknown ? any : M>\n\t\t: never\n\t\t: never\n\t) => APIzInstance<RawRequestOptions, T, Method>;\n};\n\nexport interface APIzRequestOptions<ContentType> {\n\tbody?: any;\n\tparams?: Record<string, string>;\n\tquery?: string | Record<string, any>;\n\theaders?: Record<string, any>;\n\ttype?: ContentType;\n\thandleError?: boolean;\n}\n\nexport type RequestWithoutThis<RawRequestOptions, ContentType> = (\n\toptions: APIzRequestOptions<ContentType> | RawRequestOptions,\n\tisRawOption?: boolean\n) => Promise<any>;\n\ntype Request<RawRequestOptions, ContentType, Meta, Method extends HTTPMethodLowerCase> = (\n\tthis: ParsedAPIInfo<RawRequestOptions, ContentType, Meta, Method>,\n\toptions: APIzRequestOptions<ContentType> | RawRequestOptions,\n\tisRawOption?: boolean\n) => Promise<any>;\n\nexport interface APIzRequest<RawRequestOptions, ContentType, Meta> {\n\t(options: APIzRequestOptions<ContentType> | RawRequestOptions, isRawOption?: boolean): Promise<\n\t\tany\n\t>;\n\treadonly url: string;\n\treadonly method: HTTPMethodUpperCase;\n\treadonly meta: Meta;\n\treadonly type: ContentType;\n}\n\nconst toString = ((Map as unknown) as () => any).call.bind(Object.prototype.toString);\nconst isStr = (s: any): s is string => s && typeof s === 'string';\nconst isFn = (f: any): f is Callable => typeof f === 'function';\nconst isObj = (o: any): boolean => toString(o) === '[object Object]';\n\nlet globalQuerystring: Serialize2QueryString | undefined,\n\tglobalParamRegex: RegExp | undefined,\n\tglobalClient: APIzClient<any, any, any, any> | undefined,\n\tdefaultType: any;\n\nconst defaultParamRegex = /:((\\w|-)+)/g,\n\tslashRegex = /\\/\\//g,\n\treplaceSlash = (m: string, o: number): string => (o <= 6 ? m : '/');\n\nfunction isAPIInfoWithURL<ContentType, Meta>(v: any): v is APIInfoWithURL<ContentType, Meta> {\n\treturn !!v.url;\n}\n\nfunction parseApiInfo<RawRequestOptions, ContentType, Meta, Method extends HTTPMethodLowerCase>(\n\tname: string,\n\trawInfo: APIInfo<ContentType, Meta>,\n\t{\n\t\tbaseURL: gBaseURL,\n\t\tparamRegex,\n\t\tquerystring,\n\t\tclient\n\t}: {\n\tbaseURL?: string;\n\tparamRegex: RegExp;\n\tquerystring: Serialize2QueryString;\n\tclient: APIzClient<RawRequestOptions, ContentType, Meta, Method>;\n\t}\n): ParsedAPIInfo<RawRequestOptions, ContentType, Meta, Method> {\n\tconst {\n\t\tmethod = 'GET' as HTTPMethod,\n\t\ttype = defaultType as ContentType | undefined,\n\t\tmeta\n\t} = rawInfo;\n\tlet url: string | undefined, baseURL: string | undefined, path: string | undefined;\n\n\t// 照理讲放parseApiInfo外面显得更合理一点, 不过考虑到add和实例化的时候都要校验\n\tif (name === 'add') {\n\t\tthrow new Error('\"add\" is preserved key.');\n\t}\n\n\tif (isAPIInfoWithURL<ContentType, Meta>(rawInfo)) {\n\t\turl = rawInfo.url;\n\t} else {\n\t\tbaseURL = rawInfo.baseURL;\n\t\tpath = rawInfo.path;\n\t}\n\n\tconst info = {} as ParsedAPIInfo<RawRequestOptions, ContentType, Meta, Method>,\n\t\tbURL = baseURL || gBaseURL;\n\n\tif (!isObj(rawInfo)) {\n\t\tthrow new TypeError(`API ${name} expected an object, but received ${JSON.stringify(rawInfo)}.`);\n\t}\n\tif (isStr(url)) {\n\t\tinfo.url = url;\n\t} else if (isStr(bURL)) {\n\t\tinfo.url = (bURL + (path || '')).replace(slashRegex, replaceSlash);\n\t} else {\n\t\tthrow new Error(`API \"${name}\" must set url or baseURL correctly.`);\n\t}\n\tconst methodUpperCase = method.toUpperCase() as HTTPMethodUpperCase,\n\t\tmethodLowerCase = method.toLowerCase() as Method;\n\tif (!['GET', 'HEAD', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'].includes(methodUpperCase)) {\n\t\tthrow new Error(`Unsupported HTTP method: ${methodUpperCase}.`);\n\t}\n\tif (!isFn(client[methodLowerCase])) {\n\t\tthrow new Error(`client must implement a ${methodLowerCase} function.`);\n\t}\n\tconst parts = info.url.split(/\\/(?=\\w|:)/g),\n\t\toffset = /^(https?:|\\/)/.test(parts[0]) ? 2 : 1;\n\tinfo.baseURL = parts.slice(0, offset).join('/');\n\tinfo.path = `/${parts.slice(offset).join('/')}`;\n\tinfo.name = name;\n\tinfo.meta = meta;\n\tinfo.method = methodUpperCase;\n\tinfo.methodLowerCase = methodLowerCase;\n\tinfo.client = client;\n\tinfo.type = type;\n\tinfo.regex = paramRegex;\n\tinfo.querystring = querystring;\n\tinfo.init = true;\n\treturn info;\n}\n\nfunction replaceParams(params: Record<string, string>): (m: string, v: string) => string | never {\n\treturn (m: string, v: string): string | never => {\n\t\tif (params[v] == null) {\n\t\t\tthrow new Error(`Can't find a property \"${v}\" in params.`);\n\t\t}\n\t\treturn encodeURIComponent(params[v]);\n\t};\n}\n\nfunction request<RawRequestOptions, ContentType, Meta, Method extends HTTPMethodLowerCase>(\n\tthis: ParsedAPIInfo<RawRequestOptions, ContentType, Meta, Method>,\n\toptions?: APIzRequestOptions<ContentType> | RawRequestOptions,\n\tisRawOption?: boolean\n): Promise<any> {\n\t// $以区分全局变量\n\tconst {\n\t\tmethodLowerCase,\n\t\ttype: $defaultType,\n\t\tregex,\n\t\tquerystring,\n\t\tbaseURL,\n\t\tpath,\n\t\tclient,\n\t\tmeta\n\t} = this;\n\tlet qs,\n\t\t// tslint:disable-next-line\n\t\t{query, params, body, headers, type, handleError} = (options as APIzRequestOptions<ContentType> | undefined) || {} as APIzRequestOptions<ContentType>,\n\t\turl = this.url;\n\n\tif (isRawOption === true) {\n\t\treturn client[methodLowerCase]({\n\t\t\turl,\n\t\t\tname: this.name,\n\t\t\thandleError,\n\t\t\toptions: options as RawRequestOptions | undefined\n\t\t});\n\t}\n\ttype === undefined && (type = $defaultType);\n\n\tif (params) {\n\t\turl = baseURL + path.replace(regex, replaceParams(params));\n\t}\n\n\tif (query) {\n\t\tqs = querystring(query);\n\t\turl = url.includes('?') ? `${url}&${qs}` : `${url}?${qs}`;\n\t}\n\n\treturn client[methodLowerCase]({\n\t\turl,\n\t\tname: this.name,\n\t\thandleError,\n\t\tmeta,\n\t\ttype,\n\t\tbody,\n\t\theaders,\n\t\tquery\n\t});\n}\n\nfunction createAPI<RawRequestOptions, ContentType, Meta, Method extends HTTPMethodLowerCase>(\n\tinfo: ParsedAPIInfo<RawRequestOptions, ContentType, Meta, Method>\n): APIzRequest<RawRequestOptions, ContentType, Meta> {\n\tconst fn = request.bind<Request<RawRequestOptions, ContentType, Meta, Method>>(info);\n\n\t['url', 'method', 'meta', 'type'].forEach((k: string) => {\n\t\tObject.defineProperty(fn, k, {\n\t\t\tvalue: (info as any)[k],\n\t\t\tenumerable: true,\n\t\t\twritable: true\n\t\t});\n\t});\n\treturn (fn as unknown) as APIzRequest<RawRequestOptions, ContentType, Meta>;\n}\n\nexport function APIz<\nRawRequestOptions = any,\nContentType = any,\nMeta = any,\nMethod extends HTTPMethodLowerCase = HTTPMethodLowerCase,\nT extends Record<string, APIInfo<ContentType, Meta>> = Record<string, APIInfo<ContentType, Meta>>\n>(\n\tthis: APIzInstance<RawRequestOptions, T, Method>,\n\tgroup: APIGroup<T>,\n\toptions?: APIzOptions<RawRequestOptions, ContentType, Meta, Method>\n): APIzInstance<RawRequestOptions, T, Method> {\n\tconst self = this instanceof APIz ? this : Object.create(APIz.prototype);\n\tlet baseURL: string | undefined,\n\t\tparamRegex: RegExp,\n\t\tquerystring: Serialize2QueryString | undefined,\n\t\tclient: APIzClient<RawRequestOptions, ContentType, Meta, Method> | undefined;\n\n\tisStr(group.baseURL) && (baseURL = group.baseURL);\n\n\t({\n\t\tbaseURL = baseURL,\n\t\tparamRegex = globalParamRegex || defaultParamRegex,\n\t\t// 这里querystring虽然可能为undefined, 但是后面立马检测了是否为callable,\n\t\t// 为了给js用户提示, 所以这里也可以暂时视为不为undefined\n\t\tquerystring = globalQuerystring,\n\t\tclient = globalClient\n\t} = options || {});\n\n\tif (!isFn(querystring)) {\n\t\tthrow new Error('A querystring function must set.');\n\t}\n\n\tif (!client) {\n\t\tthrow new Error('A client must set.');\n\t}\n\n\tconst groupOptions = {\n\t\tbaseURL,\n\t\tparamRegex,\n\t\tquerystring,\n\t\tclient\n\t};\n\n\tconst apis = group.apis;\n\n\t// 不用Object.keys, 允许配置对象继承\n\tfor (const key in apis) {\n\t\t// tslint:disable-next-line\n\t\tif (isObj(apis[key])) {\n\t\t\tconst info = parseApiInfo<RawRequestOptions, ContentType, Meta, Method>(\n\t\t\t\tkey,\n\t\t\t\tapis[key],\n\t\t\t\tgroupOptions\n\t\t\t);\n\t\t\tObject.defineProperty(self, key, {\n\t\t\t\tvalue: createAPI(info),\n\t\t\t\twritable: false\n\t\t\t});\n\t\t} else {\n\t\t\tconsole.warn(`The ${key} in group is not an object.`);\n\t\t}\n\t}\n\n\tself.add = function (\n\t\tname: string,\n\t\tapiInfo: APIInfo<ContentType, Meta>\n\t): APIzInstance<RawRequestOptions, T, Method> {\n\t\tif (this[name]) {\n\t\t\tthrow new Error(`API \"${name}\" already exists.`);\n\t\t}\n\t\tconst info = parseApiInfo<RawRequestOptions, ContentType, Meta, Method>(\n\t\t\tname,\n\t\t\tapiInfo,\n\t\t\tgroupOptions\n\t\t);\n\t\tthis[name] = createAPI(info);\n\t\treturn this;\n\t};\n\n\treturn self;\n}\n\nexport function config<\nRawRequestOptions,\nContentType = any,\nMeta = any,\nMethod extends HTTPMethodLowerCase = HTTPMethodLowerCase\n>(\n\t{\n\t\tquerystring,\n\t\tparamRegex,\n\t\tclient,\n\t\treset,\n\t\tdefaultType: dt\n\t}: GlobalAPIzOptions<RawRequestOptions, ContentType, Meta, Method> = {reset: true}\n): void {\n\tisFn(querystring) && (globalQuerystring = querystring);\n\tparamRegex instanceof RegExp && (globalParamRegex = paramRegex);\n\tglobalClient = client;\n\tdefaultType = dt;\n\treset &&\n\t\t(globalQuerystring = globalParamRegex = globalClient = defaultType = undefined);\n}","import { Serialize2QueryString } from './core';\n\nexport const querystring: Serialize2QueryString = function (obj: any): string {\n\tif (Object.prototype.toString.call(obj) === '[object Object]') {\n\t\treturn Object.keys(obj)\n\t\t\t.map(\n\t\t\t\t(k: string) =>\n\t\t\t\t\tArray.isArray(obj[k])\n\t\t\t\t\t\t? obj[k]\n\t\t\t\t\t\t\t.map((v: any) => `${encodeURIComponent(k)}=${encodeURIComponent(v == null ? '' : v)}`)\n\t\t\t\t\t\t\t.join('&')\n\t\t\t\t\t\t: `${encodeURIComponent(k)}=${encodeURIComponent(obj[k] == null ? '' : obj[k])}`\n\t\t\t)\n\t\t\t.join('&');\n\t} else if (typeof obj === 'string') {\n\t\treturn obj;\n\t} else {\n\t\treturn JSON.stringify(obj);\n\t}\n};","import { config } from './core';\nimport { querystring } from './querystring';\n\nconfig({\n\tquerystring,\n\tdefaultType: 'json'\n});\n\nexport * from './core';"],"names":["globalQuerystring","globalParamRegex","globalClient","defaultType","toString","Map","call","bind","Object","prototype","isStr","s","isFn","f","isObj","o","defaultParamRegex","slashRegex","replaceSlash","m","isAPIInfoWithURL","v","url","parseApiInfo","name","rawInfo","baseURL","path","gBaseURL","paramRegex","querystring","client","method","type","meta","Error","info","bURL","TypeError","JSON","stringify","replace","methodUpperCase","toUpperCase","methodLowerCase","toLowerCase","includes","parts","split","offset","test","slice","join","regex","init","replaceParams","params","encodeURIComponent","request","options","isRawOption","qs","this","$defaultType","query","body","headers","handleError","undefined","createAPI","fn","forEach","k","defineProperty","value","enumerable","writable","APIz","group","self","create","groupOptions","apis","key","console","warn","add","apiInfo","config","reset","dt","RegExp","obj","keys","map","Array","isArray"],"mappings":"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"}